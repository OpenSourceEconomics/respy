from subprocess import Popen
from subprocess import PIPE
import numpy as np
import shlex
import json

from waflib.Configure import conf

top = '.'
out = '.bld'

# GFORTRAN FLAGS, it would nice to add  '-ffpe-trap=zero,overflow,invalid' back to the debug
# flags, however this results in a failure of the KW1994 codes and we cannot just turn it off
# for their files. This does not seem straightforward as the all the flags are set in the
# configure phase.
GFORTRAN_FLAGS_DEBUG = []
GFORTRAN_FLAGS_DEBUG += ['-O', '-Wall', '-Wline-truncation', '-Wsurprising', '-Waliasing']
GFORTRAN_FLAGS_DEBUG += ['-Wunused-parameter', '-fwhole-file', '-fcheck=all']
GFORTRAN_FLAGS_DEBUG += ['-fbacktrace', '-g', '-fmax-errors=1', '-ffree-line-length-0']
GFORTRAN_FLAGS_DEBUG += ['-cpp', '-Wcharacter-truncation', '-Wimplicit-interface']

GFORTRAN_FLAGS_PRODUCTION = ['-O3', '-ffree-line-length-0', '-cpp']


def options(ctx):

    ctx.load('compiler_c')

    ctx.load('compiler_fc')

    ctx.add_option('--debug', action='store_true', dest='is_debug', help='use debug compiler flags')

    ctx.add_option('--no_parallelism', action='store_true', dest='no_parallelism',
        help='no support for parallelism')

    ctx.add_option('--no_fortran', action='store_true', dest='no_fortran',
        help='no support for FORTRAN')

    # This option is convenient in the development process as it allows to later analyze the F2PY
    # testing battery.
    ctx.add_option('--no_f2py', action='store_true', dest='no_f2py', help='no support for F2PY')


def configure(ctx):

    # Configuration
    ctx.env['DEBUG'] = ctx.configure_debug()

    ctx.env['PARALLELISM'] = ctx.check_support_parallelism()
    ctx.env['FORTRAN'] = ctx.check_support_fortran()
    ctx.env['F2PY'] = ctx.check_support_f2py()

    ctx.write_configuration()

    # We need more details for the case of parallelism.
    if ctx.env['PARALLELISM']:
        ctx.env['FC'] = 'mpif90'
        ctx.env['COMPILER_FORTRAN'] = 'mpif90'

    # Specify search path for static libraries
    ctx.env.append_unique('STLIBPATH', ['../.bld/fortran', '../.bld/tests/resources'])

    # Specify use of system libraries.
    ctx.env.append_unique('LIB', ['lapack'])

    # Specify compiler flags
    if ctx.env['DEBUG']:
        ctx.env.append_unique('FCFLAGS', GFORTRAN_FLAGS_DEBUG)
    else:
        ctx.env.append_unique('FCFLAGS', GFORTRAN_FLAGS_PRODUCTION)

    # We can only compile parts of the code if MPI is in fact available.
    if ctx.env['PARALLELISM']:
        ctx.env.append_unique('FCFLAGS', ['-DMPI_AVAILABLE'])


def build(ctx):

    if ctx.env['FORTRAN']:

        ctx.recurse('fortran')

        ctx.recurse('tests/resources')


@conf
def configure_debug(self):
    """This function determines whether F2PY is supported or not."""
    self.start_msg('Configuration DEBUG')

    if self.options.is_debug:
        is_debug = True
        message = 'True'
    else:
        is_debug = False
        message = 'False'

    self.end_msg(message)

    return is_debug


@conf
def check_support_f2py(self):
    """This function determines whether F2PY is supported or not."""
    self.start_msg('Support F2PY ')

    if self.options.no_f2py:
        is_support = False
    else:

        if self.env['FORTRAN']:
            is_support = True
        else:
            is_support = False

    self.end_msg(is_support)

    return is_support


@conf
def check_support_fortran(self):
    """This function determines whether FORTRAN is supported or not."""
    self.start_msg('Support FORTRAN ')

    if self.options.no_fortran:
        is_support = False
    else:
        try:

            # Load compiler
            self.load('compiler_fc')

            try:
                assert self.env.FC_NAME == 'GFORTRAN'
            except AssertionError:
                raise self.errors.ConfigurationError

            # Compile a small FORTRAN program
            self.check_fortran()

            # Check for LAPACK library
            self.check_fc(lib='lapack')

        except self.errors.ConfigurationError:
            is_support = False
        else:
            is_support = True

    self.end_msg(is_support)

    return is_support


@conf
def check_support_parallelism(self):
    """This function determines whether parallelism is supported or not."""
    self.start_msg('Support PARALLELISM ')

    if self.options.no_parallelism or self.options.no_fortran:
        is_support = False
    else:

        try:
            # Check for the existence of the compiler
            self.find_program('mpif90')

            # Check for MPICH implementation and version
            check_mpi_implementation(self)

        except self.errors.ConfigurationError:
            is_support = False
        else:
            is_support = True

    self.end_msg(is_support)

    return is_support


@conf
def check_mpi_implementation(self):
    """This function checks for the version of the MPICH implementation."""
    output = Popen(['mpif90', '-v'], stdout=PIPE, stderr=PIPE).communicate()[0].decode()
    implementation, version = np.array(shlex.split(output))[[2, 4]]

    # The build process is only tested for MPICH at this point.
    if implementation not in ['MPICH']:
        raise self.errors.ConfigurationError

    # We need at least version 3 to implement the master-slave paradigm.
    if int(version.split('.')[0]) < 3:
        raise self.errors.ConfigurationError


@conf
def write_configuration(self):
    """This function records the package specification in a simple file."""
    config_dict = dict()
    for label in ['DEBUG', 'PARALLELISM', 'FORTRAN', 'F2PY']:
        config_dict[label] = self.env[label]
    json.dump(config_dict, open('.bld/.config', 'w'))
